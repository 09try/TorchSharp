<#@ Template Language="C#" #>
<#@ Assembly Name="System.Core" #>
<#@ Output Extension=".generated.cs" #>
<#@ Include File="Types.ttinclude" #>
using System;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;

namespace TorchSharp.Tensor {

<#
foreach (var type in TorchTypeDef.Types) {
#>
    /// <summary>
    ///   Tensor of type <#=type.Name#>.
    ///   This tensor maps to a Torch variable (see torch/csrc/autograd/variable.h).
    //    Please do no mix Aten Tensors and Torch Tensors.
    /// </summary>
    public struct <#=type.Name#>Tensor : ITorchTensor<<#=type.Storage#>>
    {
        internal IntPtr handle;

        internal <#=type.Name#>Tensor(IntPtr handle)
        {
            this.handle = handle;
        }

        /// <summary>
        ///   Releases the tensor and its associated data.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        [DllImport("libTorchSharp")]
        extern static void THSTensor_dispose(IntPtr handle);

        /// <summary>
        ///   Implements the .NET Dispose pattern.
        /// </summary>
        public void Dispose(bool disposing)
        {
            if (disposing)
            {
                THSTensor_dispose(handle);
                handle = IntPtr.Zero;
            }
        }

        public IntPtr Handle
        {
            get
            {
                return handle;
            }
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_zeros(<#=type.Ptr#> psizes, int scalarType, int length, string device, bool requireGrad);

        /// <summary>
        ///  Create a new tensor filled with zeros
        /// </summary>
        static public ITorchTensor<<#=type.Storage#>> Zeros(long[] size, string device = "cpu", bool requiresGrad = false)
        {
            <#=type.Name#>Tensor.CheckForCUDA (device);

            unsafe
            {
                fixed (long* psizes = size)
                {
                    return new <#=type.Name#>Tensor (THSTensor_zeros ((<#=type.Ptr#>)psizes, size.Length, (sbyte)ATenScalarMapping.<#=type.Name#>, device, requiresGrad));
                }
            }
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_ones(<#=type.Ptr#> psizes, int scalarType, int length, string device, bool requireGrad);

        /// <summary>
        ///  Create a new tensor filled with ones
        /// </summary>
        static public ITorchTensor<<#=type.Storage#>> Ones(long[] size, string device = "cpu", bool requiresGrad = false)
        {
            <#=type.Name#>Tensor.CheckForCUDA (device);

            unsafe
            {
                fixed (long* psizes = size)
                {
                    return new <#=type.Name#>Tensor (THSTensor_ones ((<#=type.Ptr#>)psizes, size.Length, (sbyte)ATenScalarMapping.<#=type.Name#>, device, requiresGrad));
                }
            }
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_randn(<#=type.Ptr#> psizes, int scalarType, int length, string device, bool requireGrad);

        /// <summary>
        ///  Create a new tensor filled with random values taken from a normal distribution with mean 0 and variance 1.
        /// </summary>
        static public ITorchTensor<<#=type.Storage#>> RandomN(long[] size, string device = "cpu", bool requiresGrad = false)
        {
            <#=type.Name#>Tensor.CheckForCUDA (device);

            unsafe
            {
                fixed (long* psizes = size)
                {
                    return new <#=type.Name#>Tensor (THSTensor_randn ((<#=type.Ptr#>)psizes, size.Length, (sbyte)ATenScalarMapping.<#=type.Name#>, device, requiresGrad));
                }
            }
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_new<#=type.Name#>Scalar(<#=type.Storage#> scalar);

        public static <#=type.Name#>Tensor From(<#=type.Storage#> scalar)
        {
            return new <#=type.Name#>Tensor(THSTensor_new<#=type.Name#>Scalar(scalar));
        }

<#
if (!type.IsLong) {
#>
        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_new(IntPtr rawArray, long[] dimensions, int numDimensions, long[] strides, int numStrides, sbyte type);
<# } else { #>
        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_newLong(IntPtr rawArray, long[] dimensions, int numDimensions, long[] strides, int numStrides, sbyte type);
<# } #>

        public static <#=type.Name#>Tensor From(IntPtr rawArray, long[] dimensions)
        {
            var length = dimensions.Length;
            var strides = new long[length];

            strides[0] = 1;
            for (int i = 1; i < length; i++)
            {
                strides[i] = dimensions[i - 1];
            }

<#
if (!type.IsLong) {
#>
            return new <#=type.Name#>Tensor(THSTensor_new(rawArray, dimensions, dimensions.Length, strides, strides.Length, (sbyte)ATenScalarMapping.<#=type.Name#>));
<# } else { #>
            return new <#=type.Name#>Tensor(THSTensor_newLong(rawArray, dimensions, dimensions.Length, strides, strides.Length, (sbyte)ATenScalarMapping.<#=type.Name#>));
<# } #>
        }

        public static <#=type.Name#>Tensor From(<#=type.Storage#>[] rawArray, long[] dimensions)
        {
            unsafe
            {
                fixed (<#=type.Storage#>* parray = rawArray)
                {
                    return <#=type.Name#>Tensor.From((IntPtr)parray, dimensions);
                }
            }
        }

        public static <#=type.Name#>Tensor From(<#=type.Storage#>[] rawArray)
        {
            return From(rawArray, new long[] { (long)rawArray.Length });
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_sparse(IntPtr indices, IntPtr values, IntPtr sizes, int length, sbyte type, string device, bool requiresGrad);

        public static <#=type.Name#>Tensor Sparse(ITorchTensor<long> indices, ITorchTensor<<#=type.Storage#>> values, long[] size, string device = "cpu", bool requiresGrad = false)
        {
            <#=type.Name#>Tensor.CheckForCUDA (device);

            unsafe
            {
                fixed (long* psizes = size)
                {
                    return new <#=type.Name#>Tensor (THSTensor_sparse (indices.Handle, values.Handle, (<#=type.Ptr#>)psizes, size.Length, (sbyte)ATenScalarMapping.<#=type.Name#>, device, requiresGrad));
                }
            }
        }

        [DllImport("libTorchSharp")]
        extern static AtenSharp.<#=type.Name#>Tensor.HType THSTensor_unsafeGetTensorImpl(IntPtr handle);

        /// <summary>
        ///  Returns the number of dimensions for this tensor
        /// </summary>
        public int Dimensions
        {
            get
            {
                var atenTensor = new AtenSharp.<#=type.Name#>Tensor (THSTensor_unsafeGetTensorImpl (handle));
                return atenTensor.Dimensions;
            }
        }

        /// <summary>
        ///  Returns a pointer to the unmanaged data managed by this tensor.
        /// </summary>
        public long NumberOfElements 
        {
            get
            {
                switch (Dimensions)
                {
                    case 0: 
                        return 1;
                    case 1:
                        return (int)Shape[0];
                    default:
                        return (int)Shape.Aggregate((x, y) => x * y);
                }
            }
        }

        [DllImport("libTorchSharp")]
        extern static <#=type.Ptr#> THSTensor_data(IntPtr handle);

        /// <summary>
        ///  Returns a pointer to the unmanaged data managed by this tensor.
        /// </summary>
        public Span<<#=type.Storage#>> Data
        {
            get
            {               
                if (NumberOfElements > int.MaxValue)
                {
                    throw new ArgumentException("Span only supports up to int.MaxValue elements.");
                }
                unsafe
                {
                    return new System.Span<<#=type.Storage#>>((void*)THSTensor_data(handle), (int)NumberOfElements);
                }
            }
        }

        public <#=type.Storage#> DataItem
        {
            get
            {
                if (NumberOfElements != 1)
                {
                    throw new ArgumentException($"Number of elements in the tensor must be 1");
                }
                return Data[0];
            }
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_get1(IntPtr handle, long i1);

        public ITorchTensor<<#=type.Storage#>> this[long i1]
        {
            get
            {
                return THSTensor_get1(handle, i1).ToTorchTensor<<#=type.Storage#>>();
            }
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_get2(IntPtr handle, long i1, long i2);

        public ITorchTensor<<#=type.Storage#>> this[long i1, long i2]
        {
            get
            {
                return THSTensor_get2(handle, i1, i2).ToTorchTensor<<#=type.Storage#>>();
            }
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_get3(IntPtr handle, long i1, long i2, long i3);

        public ITorchTensor<<#=type.Storage#>> this[long i1, long i2, long i3]
        {
            get
            {
                return THSTensor_get3(handle, i1, i2, i3).ToTorchTensor<<#=type.Storage#>>();
            }
        }

        [DllImport("libTorchSharp")]
        extern static sbyte THSTensor_type(IntPtr handle);

        public ATenScalarMapping Type
        {
            get
            {
                return (ATenScalarMapping)THSTensor_type(handle);
            }
        }

        [DllImport("libTorchSharp")]
        extern static string THSTensor_deviceType(IntPtr handle);

        public string Device
        {
            get
            {
                return THSTensor_deviceType(handle);
            }
        }

        [DllImport("libTorchSharp")]
        extern static bool THSTensor_isSparse(IntPtr handle);

        public bool IsSparse
        {
            get
            {
                return THSTensor_isSparse(handle);
            }
        }

        [DllImport("libTorchSharp")]
        extern static bool THSTensor_isVariable(IntPtr handle);

        public bool IsVariable
        {
            get
            {
                return THSTensor_isVariable(handle);
            }
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_cpu(IntPtr handle);

        public ITorchTensor<<#=type.Storage#>> Cpu()
        {
            return new <#=type.Name#>Tensor(THSTensor_cpu(handle));
        }

         [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_cuda(IntPtr handle);

        public ITorchTensor<<#=type.Storage#>> Cuda()
        {
            if (!Torch.IsCudaAvailable())
            {
                throw new InvalidOperationException("CUDA non available in the current machine.");
            }

            return new <#=type.Name#>Tensor(THSTensor_cuda(handle));
        }

        /// <summary>
        ///  Retrieves the size of the specified dimension in the tensor.
        /// </summary>
        public long GetTensorDimension(int dim)
        {
            var atenTensor = new AtenSharp.<#=type.Name#>Tensor (THSTensor_unsafeGetTensorImpl (handle));
            return atenTensor.GetTensorDimension (dim);
        }

        /// <summary>
        /// Returns the tensor shape, this is an array whose size determines the number of dimensions on the tensor, and each element is the size of the dimension
        /// </summary>
        /// <remarks>
        ///     An array of size 0 is used for constants, an array of size 1 is used
        ///     for single-dimension arrays, where the dimension is the value of the
        ///     first element.   And so on.
        /// </remarks>
        public long[] Shape
        {
            get
            {
                var dims = new long[Dimensions];
                for (int i = 0; i < dims.Length; i++)
                    dims[i] = GetTensorDimension(i);

                return dims;
            }
        }

        /// <summary>
        ///  Retrieves the stride of the specified dimension in the tensor.
        /// </summary>
        public long GetTensorStride (int dim)
        {
            var atenTensor = new AtenSharp.<#=type.Name#>Tensor(THSTensor_unsafeGetTensorImpl(handle));
            return atenTensor.GetTensorStride(dim);
        }

        [DllImport("libTorchSharp")]
        extern static void THSTensor_backward(IntPtr handle);

        public void Backward()
        {
            THSTensor_backward(handle);
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_grad(IntPtr handle);

        public ITorchTensor<float> Grad()
        {
            return new FloatTensor(THSTensor_grad(handle));
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_reshape(IntPtr src, IntPtr shape, int length);

        public ITorchTensor<<#=type.Storage#>> Reshape(params long[] shape)
        {
            unsafe
            {
                fixed (long* pshape = shape)
                {
                    return new <#=type.Name#>Tensor (THSTensor_reshape (handle, (<#=type.Ptr#>)pshape, shape.Length));
                }
            }
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_transpose(IntPtr src, long dim1, long dim2);

        public ITorchTensor<<#=type.Storage#>> Transpose(long dimension1, long dimension2)
        {
            return new <#=type.Name#>Tensor (THSTensor_transpose (handle, dimension1, dimension2));
        }

        [DllImport("libTorchSharp")]
        extern static void THSTensor_transpose_(IntPtr src, long dim1, long dim2);

        public void TransposeInPlace(long dimension1, long dimension2)
        {
            THSTensor_transpose_ (handle, dimension1, dimension2);
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_view(IntPtr src, IntPtr shape, int length);

        public ITorchTensor<<#=type.Storage#>> View(params long[] shape)
        {
            unsafe
            {
                fixed (long* pshape = shape)
                {
                    return new <#=type.Name#>Tensor (THSTensor_view (handle, (<#=type.Ptr#>)pshape, shape.Length));
                }
            }
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_add(IntPtr src, int scalar, IntPtr trg);

        public ITorchTensor<<#=type.Storage#>> Add(ITorchTensor<<#=type.Storage#>> target, int scalar = 1)
        {
            return new <#=type.Name#>Tensor(THSTensor_add(handle, scalar, target.Handle));
        }

        [DllImport("libTorchSharp")]
        extern static void THSTensor_add_(IntPtr src, int scalar, IntPtr trg);

        public void AddInPlace(ITorchTensor<<#=type.Storage#>> target, int scalar)
        {
            THSTensor_add_(handle, scalar, target.Handle);
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_addbmm(IntPtr mat, IntPtr batch1, IntPtr batch2, float beta, float alpha);

        public ITorchTensor<<#=type.Storage#>> Addbmm(ITorchTensor<<#=type.Storage#>> batch1, ITorchTensor<<#=type.Storage#>> batch2, float beta, float alpha)
        {
            return new <#=type.Name#>Tensor(THSTensor_addbmm(handle, batch1.Handle, batch2.Handle, beta, alpha));
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_addmm(IntPtr mat, IntPtr mat1, IntPtr mat2, float beta, float alpha);

        public ITorchTensor<<#=type.Storage#>> Addmm(ITorchTensor<<#=type.Storage#>> mat1, ITorchTensor<<#=type.Storage#>> mat2, float beta, float alpha)
        {
            return new <#=type.Name#>Tensor(THSTensor_addmm(handle, mat1.Handle, mat2.Handle, beta, alpha));
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_argmax(IntPtr src, long dimension, bool keep_dim);

        public ITorchTensor<<#=type.Storage#>> Argmax(long dimension, bool keepDim = false)
        {
            return new <#=type.Name#>Tensor(THSTensor_argmax(handle, dimension, keepDim));
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_baddbmm(IntPtr batch1, IntPtr batch2, IntPtr mat, float beta, float alpha);

        public ITorchTensor<<#=type.Storage#>> Baddbmm(ITorchTensor<<#=type.Storage#>> batch2, ITorchTensor<<#=type.Storage#>> mat, float beta, float alpha)
        {
            return new <#=type.Name#>Tensor(THSTensor_addbmm(handle, batch2.Handle, mat.Handle, beta, alpha));
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_bmm(IntPtr batch1, IntPtr batch2);

        public ITorchTensor<<#=type.Storage#>> Bmm(ITorchTensor<<#=type.Storage#>> batch2)
        {
            return new <#=type.Name#>Tensor(THSTensor_bmm(handle, batch2.Handle));
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_eq(IntPtr src, IntPtr trg);

        public ITorchTensor<U> Eq<U>(ITorchTensor<U> target)
        {
            return THSTensor_eq(handle, target.Handle).ToTorchTensor<U>();
        }

        [DllImport("libTorchSharp")]
        extern static bool THSTensor_equal(IntPtr src, IntPtr trg);

        public bool Equal<U>(ITorchTensor<U> target)
        {
            return THSTensor_equal(handle, target.Handle);
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_exp(IntPtr src);

        public ITorchTensor<<#=type.Storage#>> Exp()
        {
            return new <#=type.Name#>Tensor(THSTensor_exp(handle));
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_matmul(IntPtr src, IntPtr target);

        public ITorchTensor<<#=type.Storage#>> MatMul(ITorchTensor<<#=type.Storage#>> target)
        {
            return new <#=type.Name#>Tensor(THSTensor_matmul(handle, target.Handle));
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_mean(IntPtr src);

        public ITorchTensor<<#=type.Storage#>> Mean()
        {
            return new <#=type.Name#>Tensor(THSTensor_mean(handle));
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_mm(IntPtr src, IntPtr target);

        public ITorchTensor<<#=type.Storage#>> Mm(ITorchTensor<<#=type.Storage#>> target)
        {
            return new <#=type.Name#>Tensor(THSTensor_mm(handle, target.Handle));
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_mul(IntPtr src, IntPtr target);

        public ITorchTensor<<#=type.Storage#>> Mul(ITorchTensor<<#=type.Storage#>> target)
        {
            return new <#=type.Name#>Tensor(THSTensor_mul(handle, target.Handle));
        }

        [DllImport("libTorchSharp")]
        extern static void THSTensor_mul_(IntPtr src, IntPtr target);

        public void MulInPlace(ITorchTensor<<#=type.Storage#>> target)
        {
            THSTensor_mul_(handle, target.Handle);
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_mulS(IntPtr src, <#=type.Storage#> scalar);

        public ITorchTensor<<#=type.Storage#>> Mul(<#=type.Storage#> scalar)
        {
            return new <#=type.Name#>Tensor(THSTensor_mulS(handle, scalar));
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_pow(IntPtr src, float scalar);

        public ITorchTensor<<#=type.Storage#>> Pow(float scalar)
        {
            return new <#=type.Name#>Tensor(THSTensor_pow(handle, scalar));
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_sigmoid(IntPtr src);

        public ITorchTensor<<#=type.Storage#>> Sigmoid()
        {
            return new <#=type.Name#>Tensor(THSTensor_sigmoid(handle));
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_sub(IntPtr src, IntPtr trg);

        public ITorchTensor<<#=type.Storage#>> Sub(ITorchTensor<<#=type.Storage#>> target)
        {
            return new <#=type.Name#>Tensor(THSTensor_sub(handle, target.Handle));
        }

        [DllImport("libTorchSharp")]
        extern static void THSTensor_sub_(IntPtr src, IntPtr trg);

        public void SubInPlace(ITorchTensor<<#=type.Storage#>> target)
        {
            THSTensor_sub_(handle, target.Handle);
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_sum(IntPtr src);

        public ITorchTensor<<#=type.Storage#>> Sum()
        {
            return new <#=type.Name#>Tensor(THSTensor_sum(handle));
        }

        // Operators overloading
        public static <#=type.Name#>Tensor operator +(<#=type.Name#>Tensor left, <#=type.Name#>Tensor right)
        {
            return (<#=type.Name#>Tensor)left.Add(right);
        }

        public static <#=type.Name#>Tensor operator *(<#=type.Name#>Tensor left, <#=type.Name#>Tensor right)
        {
            return (<#=type.Name#>Tensor)left.Mul(right);
        }

        public static <#=type.Name#>Tensor operator -(<#=type.Name#>Tensor left, <#=type.Name#>Tensor right)
        {
            return (<#=type.Name#>Tensor)left.Sub(right);
        }

        /// <summary>
        ///   Get a string representation of the tensor.
        /// </summary>
        public override string ToString()
        {
            var n = Dimensions;
            if (n == 0)
                return "[]";

            StringBuilder sb = new StringBuilder("[");
            for (int i = 0; i < n; i++)
            {
                sb.Append(GetTensorDimension(i));
                if (i + 1 < n)
                    sb.Append("x");
            }
            sb.Append("]");
            sb.Append($", device = {Device}");
            return sb.ToString();
        }

        private static void CheckForCUDA(string device)
        {
            if (!Torch.IsCudaAvailable() && device.ToLower().Contains("cuda"))
            {
                throw new InvalidOperationException("CUDA non available in the current machine.");
            }
        }
    }
<# } #>
    
    public enum ATenScalarMapping : sbyte
    {
        Byte = 0,
        Short = 2,
        Int = 3,
        Long = 4,
        Float = 6,
        Double = 7
    }

    public static class TensorExtensionMethods
    {
        internal static ITorchTensor<T> ToTorchTensor<T>(this IntPtr rawTensor)
        {
            switch (true)
            {
<#
foreach (var type in TorchTypeDef.Types) {
#>
                case bool _ when typeof(T) == typeof(<#=type.Storage#>):
                {
                    return new <#=type.Name#>Tensor(rawTensor) as ITorchTensor<T>;
                }
<#
}
#>
                default: throw new NotImplementedException($"Creating tensor of type {typeof(T)} is not supported.");
            }
        }

        public static ITorchTensor<T> ToTorchTensor<T>(this T[] rawArray, long[] dimensions)
        {
            switch (true)
            {
<#
foreach (var type in TorchTypeDef.Types) {
#>
                case bool _ when typeof(T) == typeof(<#=type.Storage#>):
                {
                    return <#=type.Name#>Tensor.From(rawArray as <#=type.Storage#>[], dimensions) as ITorchTensor<T>;
                }
<#
}
#>
                default: throw new NotImplementedException($"Creating tensor of type {typeof(T)} is not supported.");
            }
        }

        public static ITorchTensor<T> ToTorchTensor<T>(this T scalar)
        {
            switch (true)
            {
<#
foreach (var type in TorchTypeDef.Types) {
#>
                case bool _ when typeof(T) == typeof(<#=type.Storage#>):
                {
                    return <#=type.Name#>Tensor.From((<#=type.Storage#>)(object)scalar) as ITorchTensor<T>;
                }
<#
}
#>
                default: throw new NotImplementedException($"Creating tensor of type {typeof(T)} is not supported.");
            }
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_cat(IntPtr src, int len, long dim);

        public static ITorchTensor<T> Cat<T>(this ITorchTensor<T>[] tensors, long dimension)
        {
            var parray = new PinnedArray<IntPtr>();
            IntPtr tensorsRef = parray.CreateArray(tensors.Select(p => p.Handle).ToArray());

            return THSTensor_cat(tensorsRef, parray.Array.Length, dimension).ToTorchTensor<T>();
        }

        [DllImport("libTorchSharp")]
        extern static IntPtr THSTensor_stack(IntPtr src, int len, long dim);

        public static ITorchTensor<T> Stack<T>(this ITorchTensor<T>[] tensors, long dimension)
        {
            var parray = new PinnedArray<IntPtr>();
            IntPtr tensorsRef = parray.CreateArray(tensors.Select(p => p.Handle).ToArray());

            return THSTensor_stack(tensorsRef, parray.Array.Length, dimension).ToTorchTensor<T>();
        }
    }
}
