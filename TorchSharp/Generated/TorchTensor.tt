<#@ Template Language="C#" #>
<#@ Assembly Name="System.Core" #>
<#@ Output Extension=".generated.cs" #>
<#@ Include File="Types.ttinclude" #>
using System;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;

namespace TorchSharp {

<#
foreach (var type in TorchTypeDef.Types) {
#>
    /// <summary>
    ///   Tensor of type <#=type.Name#>.
    ///   This tensor maps to a Torch variable. 
    /// </summary>
    public class <#=type.Name#>Tensor : IDisposable
    {
        [DllImport("LibTorchSharp")]
        extern static AtenSharp.<#=type.Name#>Tensor.HType GetTHTensor(HType handle);

        internal sealed class HType : SafeHandle
        {
            public HType(<#=type.Ptr#> preexistingHandle, bool ownsHandle) : base(<#=type.Ptr#>.Zero, ownsHandle)
            {
                SetHandle(preexistingHandle);
            }

            // This is just for marshalling
            internal HType() : base(<#=type.Ptr#>.Zero, true)
            {
            }

            public override bool IsInvalid => handle == (<#=type.Ptr#>)0;

            protected override bool ReleaseHandle()
            {
                var atenTensor = new AtenSharp.<#=type.Name#>Tensor(GetTHTensor(this));
                atenTensor.Dispose();
                return true;
            }

            protected override void Dispose(bool disposing)
            {
                if (disposing)
                {
                    ReleaseHandle();
                }
            }
        }

        internal HType handle;

        internal <#=type.Name#>Tensor(HType handle)
        {
            this.handle = handle;
        }

        /// <summary>
        ///  Finalizer for ~<#=type.Name#>Tensor
        /// </summary>
        ~<#=type.Name#>Tensor()
        {
            Dispose(false);
        }

        /// <summary>
        ///   Releases the tensor and its associated data.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        ///   Implements the .NET Dispose pattern.
        /// </summary>
        protected void Dispose(bool disposing)
        {
            if (disposing)
            {
                handle.Dispose();
                handle.SetHandleAsInvalid();
            }
        }

        /// <summary>
        ///  Returns the number of dimensions for this tensor
        /// </summary>
        public int Dimensions
        {
            get
            {
                var atenTensor = new AtenSharp.<#=type.Name#>Tensor (GetTHTensor (handle));
                return atenTensor.Dimensions;
            }
        }

        /// <summary>
        ///  Retrieves the size of the specified dimension in the tensor.
        /// </summary>
        public long GetTensorDimension(int dim)
        {
            var atenTensor = new AtenSharp.<#=type.Name#>Tensor (GetTHTensor (handle));
            return atenTensor.GetTensorDimension (dim);
        }

        /// <summary>
        /// Returns the tensor shape, this is an array whose size determines the number of dimensions on the tensor, and each element is the size of the dimension
        /// </summary>
        /// <remarks>
        ///     An array of size 0 is used for constants, an array of size 1 is used
        ///     for single-dimension arrays, where the dimension is the value of the
        ///     first element.   And so on.
        /// </remarks>
        public long[] Shape
        {
            get
            {
                var dims = new long[Dimensions];
                for (int i = 0; i < dims.Length; i++)
                    dims[i] = GetTensorDimension(i);

                return dims;
            }
        }

        /// <summary>
        ///  Retrieves the stride of the specified dimension in the tensor.
        /// </summary>
        public long GetTensorStride (int dim)
        {
            var atenTensor = new AtenSharp.<#=type.Name#>Tensor(GetTHTensor(handle));
            return atenTensor.GetTensorStride(dim);
        }

        [DllImport("LibTorchSharp")]
        extern static <#=type.Ptr#> Tensor_data(HType handle);

        /// <summary>
        ///  Returns a pointer to the unmanaged data managed by this tensor.
        /// </summary>
        public Span<<#=type.Storage#>> Data
        {
            get
            {
                
                int length;
                switch (Dimensions)
                {
                    case 0: 
                        length = 1;
                        break;
                    case 1:
                        length = (int)Shape[0];
                        break;
                    default:
                        length = (int)Shape.Aggregate((x, y) => x * y);
                        break;
                }
                
                unsafe
                {
                    return new System.Span<<#=type.Storage#>>((void*)Tensor_data(handle), length);
                }
            }
        }

        public <#=type.Storage#> Item()
        {
            unsafe
            {
                return Data[0];
            }
        }

        [DllImport("LibTorchSharp")]
        extern static string Tensor_device(HType handle);

        public string getDevice()
        {
            return Tensor_device(handle);
        }

        [DllImport("LibTorchSharp")]
        extern static HType Tensor_ones(<#=type.Ptr#> psizes, int scalarType, int length, string device, bool requireGrad);

        /// <summary>
        ///  Create a new tensor filled with ones
        /// </summary>
        static public <#=type.Name#>Tensor Ones(long[] size, string device = "cpu:0", bool requiresGrad = false)
        {
            unsafe
            {
                fixed (long* psizes = size)
                {
                    return new <#=type.Name#>Tensor (Tensor_ones ((<#=type.Ptr#>)psizes, size.Length, (short)ATenScalarMapping.<#=type.Name#>, device, requiresGrad));
                }
            }
        }

        [DllImport("LibTorchSharp")]
        extern static HType Tensor_randn(<#=type.Ptr#> psizes, int scalarType, int length, string device, bool requireGrad);

        /// <summary>
        ///  Create a new tensor filled with ones
        /// </summary>
        static public <#=type.Name#>Tensor RandomN(long[] size, string device = "cpu:0", bool requiresGrad = false)
        {
            unsafe
            {
                fixed (long* psizes = size)
                {
                    return new <#=type.Name#>Tensor (Tensor_randn ((<#=type.Ptr#>)psizes, size.Length, (short)ATenScalarMapping.<#=type.Name#>, device, requiresGrad));
                }
            }
        }

        [DllImport("LibTorchSharp")]
        extern static void Backward(HType handle);

        public void Backward()
        {
            Backward(handle);
        }

        [DllImport("LibTorchSharp")]
        extern static FloatTensor.HType Grad(HType handle);

        public FloatTensor Grad()
        {
            return new FloatTensor(Grad(handle));
        }

        [DllImport("LibTorchSharp")]
        extern static HType Sub_(HType src, HType trg, bool is_grad);

        public <#=type.Name#>Tensor SubInPlace(<#=type.Name#>Tensor target, bool no_grad = true)
        {
            return new <#=type.Name#>Tensor(Sub_(handle, target.handle, !no_grad));
        }

        [DllImport("LibTorchSharp")]
        extern static HType Mul(HType src, <#=type.Storage#> scalar, bool is_grad);

        public <#=type.Name#>Tensor Mul(<#=type.Storage#> scalar, bool no_grad = true)
        {
            return new <#=type.Name#>Tensor(Mul(handle, scalar, !no_grad));
        }

        /// <summary>
        ///   Get a string representation of the tensor.
        /// </summary>
        public override string ToString()
        {
            var n = Dimensions;
            if (n == 0)
                return "[]";

            StringBuilder sb = new StringBuilder("[");
            for (int i = 0; i < n; i++)
            {
                sb.Append(GetTensorDimension(i));
                if (i + 1 < n)
                    sb.Append("x");
            }
            sb.Append("]");
            sb.Append($", device = {getDevice()}");
            return sb.ToString();
        }
    }
<# } #>
    
    internal enum ATenScalarMapping : short
    {
        Byte = 0,
        Short = 2,
        Int = 3,
        Long = 4,
        Float = 6,
        Double = 7
    }
}
