<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
using System;
using System.Runtime.InteropServices;

namespace PytorchSharp {
<#
foreach (var type in new [] { 
    new { ApiName = "Byte", Storage = "byte" }, 
    new { ApiName = "Short", Storage = "short" },   
    new { ApiName = "Int", Storage = "int" },
    new { ApiName = "Long", Storage = "long" },
    new { ApiName = "Double", Storage = "double" },
    new { ApiName = "Float", Storage = "float" },
     }){
        string tname = type.ApiName;
        string ttype = type.Storage;
       
#>

    public class <#=tname#>Storage : IDisposable {
        SafeHandle handle;
        
        void CheckHandle ()
        {
            if (handle.IsInvalid)
                throw new ObjectDisposedException ("The storage has been disposed");
        }

        [DllImport ("caffe2")]
        extern static SafeHandle TH<#=tname#>Storage_new ();
        
        public <#=tname#>Storage ()
        {
            handle = TH<#=tname#>Storage_new ();
        }
        
        [DllImport ("caffe2")]
        extern static SafeHandle TH<#=tname#>Storage_new_with_size (IntPtr size);
        
        public <#=tname#>Storage (long size)
        {
            handle = TH<#=tname#>Storage_new_with_size ((IntPtr) size);
        }
        
        ~<#=tname#>Storage ()
        {
            Dispose (false);
        }
        
        public void Dispose ()
        {
            Dispose (true);
            GC.SuppressFinalize (this);
        }
        
        [DllImport ("caffe2")]
        extern static void TH_<#=tname#>Storage_free (SafeHandle handle);
        
        public void Dispose (bool disposing)
        {
            if (disposing){
                TH_<#=tname#>Storage_free (handle);
                handle.Dispose ();
            }
        }
        
        [DllImport ("caffe2")]
        extern static <#=ttype#> TH_<#=tname#>Storage_get (SafeHandle handle, /*ptrdiff_t*/IntPtr pos);
        
        [DllImport ("caffe2")]
        extern static void TH_<#=tname#>Storage_set (SafeHandle handle, /*ptrdiff_t*/IntPtr pos,  <#=ttype#> value);
        
        public <#=ttype#> this [long index] {
            get {
                CheckHandle ();
            
                return  TH_<#=tname#>Storage_get (handle, (IntPtr) (index));
            }
            set {
                CheckHandle ();

                TH_<#=tname#>Storage_set (handle, (IntPtr) (index), value);
            }
        }
        
        [DllImport ("caffe2")]
        extern static <#=ttype#> TH_<#=tname#>Storage_resize (SafeHandle handle, /*ptrdiff_t*/UIntPtr newSize);
        
        public void Resize (ulong size)
        {
            CheckHandle ();
            TH_<#=tname#>Storage_resize (handle, (UIntPtr) size);
        }

        [DllImport ("caffe2")]
        extern static void TH_<#=tname#>Storage_fill (SafeHandle handle, <#=ttype#> value);
        
        public void Fill (<#=ttype#> value)
        {
            CheckHandle ();
            TH_<#=tname#>Storage_fill (handle, value);
        }
    }
    
    public class <#=tname#>Tensor : IDisposable {
        SafeHandle handle;
        
        void CheckHandle ()
        {
            if (handle.IsInvalid)
                throw new ObjectDisposedException ("The tensor has been disposed");
        }
        
        [DllImport ("caffe2")]
        extern static SafeHandle TH<#=tname#>Tensor_new ();
        
        public <#=tname#>Tensor ()
        {
            handle = TH<#=tname#>Tensor_new ();
        }
        
        ~<#=tname#>Tensor ()
        {
            Dispose (false);
        }
        
        public void Dispose ()
        {
            Dispose (true);
            GC.SuppressFinalize (this);
        }
        
        [DllImport ("caffe2")]
        extern static void TH_<#=tname#>Tensor_free (SafeHandle handle);
        
        public void Dispose (bool disposing)
        {
            if (disposing){
                TH_<#=tname#>Tensor_free (handle);
                handle.Dispose ();
            }
        }
        
        
    }
<#
}
#>
}